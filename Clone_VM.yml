---
- name: Deploy and configure VM from template
  hosts: localhost
  gather_facts: false

  vars_files:
    - vars.yml

  tasks:
    - name: Gather VM info from vCenter
      community.vmware.vmware_guest_info:
        hostname: "{{ vcenter_hostname }}"
        username: "{{ vcenter_username }}"
        password: "{{ vcenter_password }}"
        validate_certs: false
        name: "{{ vm_name }}"
        datacenter: "{{ datacenter_name }}"
      register: vm_info
      failed_when: false

    - name: Set fact if VM exists
      ansible.builtin.set_fact:
        vm_exists: "{{ vm_info.instance is defined }}"

    - name: Debug VM existence
      ansible.builtin.debug:
        msg: "VM '{{ vm_name }}' already exists in vCenter."
      when: vm_exists

    - name: Fail if VM already exists
      ansible.builtin.fail:
        msg: "VM '{{ vm_name }}' already exists. Aborting clone."
      when: vm_exists

    - name: Determine base folder based on VM name
      ansible.builtin.set_fact:
        base_folder: >-
          {{
            "Ansible_Lab/VM's-LAN" if "PRD" in vm_name | upper else
            "Ansible_Lab/VM's-LAN" if "DRC" in vm_name | upper else
            "Ansible_Lab/VM's-Test" if "TST" in vm_name | upper else
            "Ansible_Lab/VM's-UAT" if "UAT" in vm_name | upper else
            "Ansible_Lab/VM's-UAT" if "PPD" in vm_name | upper else
            "Discovered virtual machine"
          }}

    - name: Determine subfolder based on template name
      ansible.builtin.set_fact:
        sub_folder: >-
          {{
            'Windows' if 'Windows' in template_name else
            'Linux&Other'
          }}

    - name: Determine final folder path
      ansible.builtin.set_fact:
        vm_folder: >-
          {{
            base_folder if base_folder == "Discovered virtual machine"
            else base_folder ~ '/' ~ sub_folder
          }}

    - name: Debug final folder path
      ansible.builtin.debug:
        msg: "VM will be placed in folder: {{ vm_folder }}"

    - name: Warn if VM is placed in default folder
      ansible.builtin.debug:
        msg: "WARNING: VM '{{ vm_name }}' is being placed in the default folder 'Discovered virtual machine'. Check naming conventions."
      when: base_folder == "Discovered virtual machine"

    - name: Calculate cores per socket for VM hardware
      ansible.builtin.set_fact:
        vm_cpu_cores_per_socket: >-
          {% set cpu = vm_cpu | int %}
          {% if cpu <= 2 %}
          {{ cpu }}
          {% else %}
          {{ [cpu // 2, 32] | min }}
          {% endif %}

    - name: Determine if Windows disk customization is required
      ansible.builtin.set_fact:
        windows_disk_customization_required: >-
          {{
            ('Windows' in template_name)
            and (
              (vm_data_disk1 | default(0) | int) > 0 or
              (vm_data_disk2 | default(0) | int) > 0
            )
          }}

    - name: Build Windows disk initialization script
      ansible.builtin.set_fact:
        windows_disk_init_script: |
          $letters = @()
          {% if (vm_data_disk1 | default(0) | int) > 0 %}
          $letters += 'D'
          {% endif %}
          {% if (vm_data_disk2 | default(0) | int) > 0 %}
          $letters += 'E'
          {% endif %}
          if ($letters.Count -eq 0) { return }
          $candidateDisks = Get-Disk | Where-Object { $_.PartitionStyle -eq 'RAW' -or $_.IsOffline -eq $true } | Sort-Object Number
          for ($i = 0; $i -lt [Math]::Min($letters.Count, $candidateDisks.Count); $i++) {
            $diskNumber = $candidateDisks[$i].Number
            $driveLetter = $letters[$i]
            Set-Disk -Number $diskNumber -IsOffline:$false -IsReadOnly:$false -ErrorAction Stop
            Initialize-Disk -Number $diskNumber -PartitionStyle GPT -Confirm:$false
            New-Partition -DiskNumber $diskNumber -UseMaximumSize -DriveLetter $driveLetter | Out-Null
            Format-Volume -DriveLetter $driveLetter -FileSystem NTFS -NewFileSystemLabel "Data$driveLetter" -Confirm:$false
          }
      when: windows_disk_customization_required
        # Clone task with conditional parameters
    - name: Clone VM with conditional customization, NICs, and disks (LSI Logic SAS)
      community.vmware.vmware_guest:
        hostname: "{{ vcenter_hostname }}"
        username: "{{ vcenter_username }}"
        password: "{{ vcenter_password }}"
        validate_certs: false
        datacenter: "{{ datacenter_name }}"
        cluster: "{{ cluster_name }}"
        datastore: "{{ datastore_name }}"
        name: "{{ vm_name }}"
        template: "{{ template_name }}"
        folder: "{{ vm_folder }}"
        hardware:
          memory_mb: "{{ vm_memory | int * 1024 }}"
          num_cpus: "{{ vm_cpu }}"
          num_cpu_cores_per_socket: "{{ vm_cpu_cores_per_socket }}"
        # Windows -> poweredon ; Nonâ€‘Windows -> poweredoff
        state: "{{ 'poweredon' if ('Windows' in template_name) else 'poweredoff' }}"

        # Networks only for Windows (so customization has matching NIC mapping)
        networks: "{{ [
          {
            'name': vm_nic,
            'ip': vm_ip,
            'gateway': vm_gateway,
            'netmask': vm_netmask,
            'dns_servers': vm_dns,
            'start_connected': True,
            'state': 'present',
            'type': 'static'
          }
        ] if ('Windows' in template_name) else omit }}"

        # Disks added at cloning
        disk: >-
          {{
            (
              [
                {
                  'size_gb': (vm_data_disk1 | default(0)) | int,
                  'type': vm_disk_type,
                  'controller_type': 'lsilogicsas',
                  'controller_number': 0,
                  'unit_number': 1
                },
                {
                  'size_gb': (vm_data_disk2 | default(0)) | int,
                  'type': vm_disk_type,
                  'controller_type': 'lsilogicsas',
                  'controller_number': 0,
                  'unit_number': 2
                }
              ]
              | selectattr('size_gb', '>', 0)
              | list
            )
            if ('Windows' in template_name)
            else [
              {
                'size_gb': [ (vm_memory | int // 2), 32 ] | min,
                'type': vm_disk_type,
                'controller_type': 'paravirtual',
                'controller_number': 0,
                'unit_number': 2
              },
              {
                'size_gb': vm_data_disk1 | int,
                'type': vm_disk_type,
                'controller_type': 'paravirtual',
                'controller_number': 0,
                'unit_number': 3
              }
            ]
          }}

        # Guest OS customization only for Windows (hostname)
        # Customization: "{{ {'hostname': vm_name} if ('Windows' in template_name) else omit }}"
        
        customization: >-
          {{
            {
              'hostname': vm_name,
              'password': windows_admin_password,
              'timezone': 130
            } if ('Windows' in template_name) else omit
          }}

        # Waits only for Windows
        wait_for_customization: "{{ True if ('Windows' in template_name) else omit }}"

      
      # Add here DRS Rules

    - name: Add PRD VM to Tetarom DRS group
      community.vmware.vmware_drs_group_manager:
        hostname: "{{ vcenter_hostname }}"
        username: "{{ vcenter_username }}"
        password: "{{ vcenter_password }}"
        validate_certs: false
        datacenter: "{{ datacenter_name }}"
        cluster: "{{ cluster_name }}"
        group_name: "Tetarom VMs"
        vms:
          - "{{ vm_name }}"
        state: present
      when: "'PRD' in vm_name | upper"
      delegate_to: localhost

    - name: Enforce Tetarom VM/Host DRS rule
      community.vmware.vmware_vm_host_drs_rule:
        hostname: "{{ vcenter_hostname }}"
        username: "{{ vcenter_username }}"
        password: "{{ vcenter_password }}"
        validate_certs: false
        datacenter: "{{ datacenter_name }}"
        cluster_name: "{{ cluster_name }}"
        drs_rule_name: "VMs in Tetarom"
        vm_group_name: "Tetarom VMs"
        host_group_name: "Tetarom Hosts"
        affinity_rule: true
        enabled: true
        mandatory: true
        state: present
      when: "'PRD' in vm_name | upper"
      delegate_to: localhost

    - name: Add DRC VM to Zorilor DRS group
      community.vmware.vmware_drs_group_manager:
        hostname: "{{ vcenter_hostname }}"
        username: "{{ vcenter_username }}"
        password: "{{ vcenter_password }}"
        validate_certs: false
        datacenter: "{{ datacenter_name }}"
        cluster: "{{ cluster_name }}"
        group_name: "Zorilor VMs"
        vms:
          - "{{ vm_name }}"
        state: present
      when: "'DRC' in vm_name | upper"
      delegate_to: localhost

    - name: Enforce Zorilor VM/Host DRS rule
      community.vmware.vmware_vm_host_drs_rule:
        hostname: "{{ vcenter_hostname }}"
        username: "{{ vcenter_username }}"
        password: "{{ vcenter_password }}"
        validate_certs: false
        datacenter: "{{ datacenter_name }}"
        cluster_name: "{{ cluster_name }}"
        drs_rule_name: "VMs in Zorilor"
        vm_group_name: "Zorilor VMs"
        host_group_name: "Zorilor Hosts"
        affinity_rule: true
        enabled: true
        mandatory: true
        state: present
      when: "'DRC' in vm_name | upper"
      delegate_to: localhost

    - name: Tokenize VM name for application separation
      ansible.builtin.set_fact:
        vm_name_tokens: "{{ vm_name.split('-') }}"

    - name: Determine application and role tokens for DRS separation
      ansible.builtin.set_fact:
        vm_app_prefix_token: "{{ vm_name_tokens | first | default('') }}"
        vm_app_role_token: "{{ (vm_name_tokens | length > 1) | ternary(vm_name_tokens[1], '') }}"
      when:
        - vm_name_tokens | length >= 2
        - (vm_name_tokens | first | default('')) | length >= 3
        - (((vm_name_tokens | length > 1) | ternary(vm_name_tokens[1], '')) | length >= 3)

    - name: Build application separation scope
      ansible.builtin.set_fact:
        vm_app_rule_scope: "{{ (vm_app_prefix_token[0:3] | upper) ~ '-' ~ (vm_app_role_token[0:3] | upper) }}"
      when:
        - vm_app_prefix_token is defined
        - vm_app_role_token is defined

    - name: Build application separation metadata
      ansible.builtin.set_fact:
        vm_app_rule_name: "Separate {{ vm_app_rule_scope }}"
        vm_app_regex: "{{ '(?i)^' ~ (vm_app_prefix_token | regex_escape) ~ '-' ~ (vm_app_role_token | regex_escape) ~ '.*' }}"
        vm_app_rule_required: true
      when:
        - vm_app_rule_scope is defined

    - name: Gather VM inventory for application rule candidates
      community.vmware.vmware_vm_info:
        hostname: "{{ vcenter_hostname }}"
        username: "{{ vcenter_username }}"
        password: "{{ vcenter_password }}"
        validate_certs: false
        vm_type: vm
      register: vm_app_inventory
      when: vm_app_rule_required | default(false)
      delegate_to: localhost

    - name: Filter VMs that belong to the same application
      ansible.builtin.set_fact:
        vm_app_detected_members: >-
          {{
            (vm_app_inventory.virtual_machines | default([]))
            | map(attribute='guest_name')
            | select('match', vm_app_regex)
            | list
          }}
      when: vm_app_rule_required | default(false)

    - name: Gather existing DRS VM-VM rules for cluster
      community.vmware.vmware_drs_rule_info:
        hostname: "{{ vcenter_hostname }}"
        username: "{{ vcenter_username }}"
        password: "{{ vcenter_password }}"
        validate_certs: false
        cluster_name: "{{ cluster_name }}"
      register: vm_app_drs_info
      when: vm_app_rule_required | default(false)
      delegate_to: localhost

    - name: Extract current application separation rule members
      ansible.builtin.set_fact:
        vm_app_existing_members: "{{ app_rule.rule_vms | default([]) }}"
      vars:
        drs_rule_items: "{{ vm_app_drs_info.drs_rule_info | default({}) | dict2items | map(attribute='value') | list | sum(start=[]) }}"
        app_rule: "{{ (drs_rule_items | selectattr('rule_type', 'equalto', 'vm_vm_rule') | selectattr('rule_name', 'equalto', vm_app_rule_name) | list | first | default({})) }}"
      when: vm_app_rule_required | default(false)

    - name: Build final VM list for application separation rule
      ansible.builtin.set_fact:
        vm_app_rule_members_final: "{{ ((vm_app_existing_members | default([])) + (vm_app_detected_members | default([])) + [vm_name]) | unique }}"
      when: vm_app_rule_required | default(false)

    - name: Ensure application separation (anti-affinity) rule exists
      community.vmware.vmware_vm_vm_drs_rule:
        hostname: "{{ vcenter_hostname }}"
        username: "{{ vcenter_username }}"
        password: "{{ vcenter_password }}"
        validate_certs: false
        cluster_name: "{{ cluster_name }}"
        drs_rule_name: "{{ vm_app_rule_name }}"
        affinity_rule: false
        enabled: true
        mandatory: true
        vms: "{{ vm_app_rule_members_final }}"
        state: present
      when:
        - vm_app_rule_required | default(false)
        - (vm_app_rule_members_final | default([])) | length > 1
      delegate_to: localhost

    - name: Initialize Windows data disks via WinRM
      when: windows_disk_customization_required
      block:
        - name: Wait for WinRM to become available on guest
          ansible.builtin.wait_for:
            host: "{{ vm_ip }}"
            port: "{{ winrm_port }}"
            delay: "{{ winrm_wait_delay }}"
            timeout: "{{ winrm_wait_timeout }}"
            state: started

        - name: Register Windows guest for WinRM operations
          ansible.builtin.add_host:
            name: "{{ vm_name }}"
            ansible_host: "{{ vm_ip }}"
            ansible_connection: winrm
            ansible_port: "{{ winrm_port }}"
            ansible_user: "{{ windows_admin_user }}"
            ansible_password: "{{ windows_admin_password }}"
            ansible_winrm_transport: "{{ winrm_transport }}"
            ansible_winrm_server_cert_validation: "{{ winrm_server_cert_validation }}"

        - name: Bring Windows data disks online and format
          ansible.windows.win_shell: "{{ windows_disk_init_script }}"
          delegate_to: "{{ vm_name }}"
